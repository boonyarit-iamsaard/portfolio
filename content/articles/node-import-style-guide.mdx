---
title: Node.js Import Style Guide
description: A practical guide to the different ways you can import built-in modules in Node.js ‚Äî and why the way you import matters.
tags: ['node']
slug: node-import-style-guide
date: 2025-04-11 13:00
---

> A practical guide to the different ways you can import built-in modules in Node.js ‚Äî and why the way you import matters.

## üìù TL;DR

- Use `import { method } from 'node:module'` for clarity, performance, and future-proofing.
- The `node:` prefix makes it clear you‚Äôre importing a built-in module (not an npm package).
- Named imports help with tree-shaking and reduce bundle size.
- Avoid default imports like `import fs from 'fs'` unless you really need the whole module.
- Works best in Node.js 16+.

## üß± Import Variations in Node.js Built-in Modules

### Basic Import

```js
import path from 'path';

path.join();
```

- Entire module as default export.
- Requires `"type": "module"` in `package.json`.
- Less tree-shakable.

### Named Import

```js
import { readFile } from 'fs';

readFile();
```

- Only imports what you need.
- More efficient and readable.

### Node Protocol Import

```js
import fs from 'node:fs';

fs.readFile();
```

- Explicitly tells Node you're using a built-in.
- Avoids confusion and improves performance.

### Modern Approach (Named + node:) ‚úÖ

```js
import { readFile } from 'node:fs/promises';
import { join } from 'node:path';
```

- Best practice.
- Combines tree-shaking, clarity, and Node-specific context.

## üì¶ Common Module Examples

### File System

```js
import { readFileSync, writeFileSync } from 'node:fs';
import { readFile, writeFile } from 'node:fs/promises';
```

### Path

```js
import { dirname, join, resolve } from 'node:path';
```

### URL

```js
import { fileURLToPath } from 'node:url';
```

### Utils

```js
import { promisify } from 'node:util';
```

## ‚úÖ Best Practices

### Use this:

```js
import { method } from 'node:module';
```

### Because:

- `node:` is more explicit and recommended since Node.js v16
- Named imports = better performance and DX
- Clearer to humans and machines
- Helps IDEs help _you_
- Makes your imports cleaner and easier to refactor

## üß† Final Thoughts

Modern JavaScript in Node.js deserves modern import patterns. Use the `node:` protocol and named imports to keep your codebase sharp, lean, and future-proof.

Let your imports tell a clear story. Happy coding!
